<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="com.obiscr.chatgpt.settings.EasyCodeState">
    <option name="projectFiles" value="$PROJECT_DIR$/compression_decompression_service.go;/Users/george/Work/personal/huffman-compression-tool/huffman_tree.go;/Users/george/Work/personal/huffman-compression-tool/input_validator.go;/Users/george/Work/personal/huffman-compression-tool/main.go" />
    <option name="forceFullIndex" value="false" />
    <option name="fileSummaryMaps" value="{&quot;/Users/george/Work/personal/huffman-compression-tool&quot;:&quot;{\&quot;/main.go\&quot;:\&quot;This Go file implements a command line utility for compressing and decompressing files.\\n\\nThe key things it does:\\n\\n- Parses the command line arguments to determine the input and destination file indexes\\n- Defines a flag for the operation type (compression or decompression)\\n- Validates the number and format of arguments passed\\n- Calls the appropriate compression or decompression function based on the operation flag\\n\\nKey functions:\\n\\n- computeArgsIndex: Determines the indexes of the input and destination files in the args slice\\n- ValidateArgsNumber: Validates the number of args passed \\n- ValidateFileName: Validates the input file name\\n- ValidateDestination: Validates the destination file/path\\n- ValidateOperationFlag: Validates the operation flag value\\n- Compress: Compression logic\\n- Decompress: Decompression logic\\n\\nSo in summary, it implements a basic command line utility to compress/decompress files with flag-based operation selection and argument validation.\&quot;,\&quot;/input_validator.go\&quot;:\&quot;This file contains input validation functions for a command line program.\\n\\nThe key functions are:\\n\\n- ValidateArgsNumber: Validates that the number of arguments passed in is either 3 or 4.\\n\\n- ValidateFileName: Validates that the input file name argument is not empty. \\n\\n- ValidateDestination: Validates that the destination file name argument is not empty.\\n\\n- ValidateOperationFlag: Validates that the optional operation flag argument is either \\\&quot;compression\\\&quot; or \\\&quot;decompression\\\&quot;.\\n\\nThe purpose of these functions is to validate the arguments passed to the program and check for any invalid or missing values. This helps ensure the program receives valid input and prevents errors from incorrect usage. The functions log errors and exit if any validation checks fail.\\n\\nSo in summary, this file contains reusable input validation logic to validate the command line arguments for a command line program.\&quot;,\&quot;/compression_decompression_service.go\&quot;:\&quot;This file implements a compression and decompression service using Huffman coding.\\n\\nThe key functions are:\\n\\n- computeFrequencyTable - Takes a file name and returns a map of character frequencies\\n- computeHuffmanTree - Takes the frequency table and builds a Huffman tree \\n- computePrefixTable - Takes the Huffman tree and builds a prefix table mapping characters to bit codes\\n- writeHeader - Writes the prefix table header to the compressed file\\n- writeToFile - Compresses the input file using the prefix table and writes it to disk\\n- extractHeaderSize - Reads and parses the header size from the compressed file\\n- extractPrefixTable - Reads and parses the prefix table from the compressed file header  \\n- composeInversePrefixTable - Inverts the prefix table for decompression\\n- Compress - Main compression function that calls all compression steps\\n- Decompress - Main decompression function that reads the compressed file and writes decompressed data using the prefix table\\n\\nSo in summary, it implements Huffman coding compression and decompression using frequency analysis, prefix coding, and bit-level encoding/decoding via the key functions listed above.\&quot;,\&quot;/huffman_tree.go\&quot;:\&quot;This file implements a Huffman tree data structure in Go.\\n\\nThe key functions are:\\n\\n- PriorityQueue: Implements a min-heap priority queue to store HuffmanNodes. Key methods are insert(), removeMin(), heapify(), size().\\n\\n- HuffmanNode: Represents a node in the Huffman tree. Stores weight, element, left and right child pointers.\\n\\n- toString(): Recursively prints a HuffmanNode and its subtree. \\n\\n- heapify(): Maintains the min-heap property when inserting/removing nodes from the priority queue.\\n\\n- insert(): Inserts a new node into the priority queue, maintaining the heap.\\n\\n- removeMin(): Removes and returns the minimum weight node from the priority queue.\\n\\nThis allows building a Huffman tree by:\\n\\n1. Inserting all initial nodes into the priority queue \\n2. Repeatedly removing the two minimum nodes and creating a new combined node\\n3. Inserting the combined nodes back into the queue\\n4. Repeating until a single root node remains, representing the complete Huffman tree.\\n\\nSo in summary, it implements a priority queue backed min-heap to efficiently build a Huffman compression tree from frequency data.\&quot;}&quot;}" />
  </component>
</project>